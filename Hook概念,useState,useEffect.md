### Hook概念

#### 1.什么是Hook？

> Hook的本质： 一套能够使函数组件更强大，更灵活的钩子

经过多年的实战，函数组件是一个更加匹配React的设计理念UI = f（data）

也更有利于逻辑拆分与重用的组件表达形式，而先前的函数组件是不可以有自己的状态的，为了能让函数组件可以拥有自己的状态，所以从v16.8开始，hooks应运而生。

注意点：

+ 1.有了hooks之后，为了兼容老版本，class类组件并没有被移除，二者都可以使用
+ 2.有了hooks之后，不能再把函数变成无状态组件了，因为hooks为函数提供了状态
+ hooks只能在函数组件中使用

#### 2.hooks的出现解决了两个问题

+ 1.组件的状态逻辑复用
+ 2.class组件自身的问题

组件的逻辑复用：

​	在hooks出现之前，react先后尝试了mixins混入，HOC高阶组件，render-props等模式

但是都有各自的问题，比如mixin的数据来源不清晰，高阶组件的嵌套问题

class组件自身的问题：

class组件就像一个厚重的‘战舰’一样，大而全，提供了很多东西，有不可忽视的学习成本，比如各种生命周期，this的指向问题等，而我们更多时候需要的是一个轻快灵活的‘快艇’

#### 3.Hooks优势：

+ 1.告别了难以理解的class
+ 2.解决业务逻辑难以拆分的问题
+ 3.使状态逻辑复用变得简单可行
+ 4.函数组件在设计思想上，更加契合React的理念

#### 4.useState

使用步骤:

1.从react中导入useState这个方法

2.在函数组件的内部执行这个方法，并且传入一个初始值

3.通过解构赋值，得到数据状态和一个修改数据状态的方法

4.渲染数据状态，在某个时机下通过执行方法修改状态

const [count,setCount] = useState(0)

5.useState传过来的参数，作为count的初始值

6.[count,setCount] 这里的写法是一个解构赋值，useState返回值是一个数组

7.setCount函数作用,用来修改count 依旧保持不能拿直接修改原值，还是生成一个新值替换原值，setCount(基于原值计算得到的新值）

8. count和setCount是一对，是绑在一起的，setCount只能用来修改对应的count值



#### 5.组件的更新过程

函数组件使用useState hook后的执行过程

+ 组件第一次渲染
  +  从头开始执行该组件中的代码逻辑
  + 调用useState(0)，将传入的参数作为状态初始值，即：0
  + 渲染组件，此时，获取到的状态count值为：0
+ 组件第二次渲染
  + 点击按钮调用setCount(count + 1)修改状态，因为状态发生改变，所以该组件会重新渲染
  + 组件重新渲染时，会再次执行该组件中的代码逻辑
  + 再次调用useState(0),此时React内部回拿到最新的状态值而非初始值，比如案例中最新状态值为1
  + 再次渲染组件，获取的状态count值为1

#### 6.组件的使用规则

1.useState函数可以执行多次，每次执行相互独立，每调用一次为函数组件提供一个状态

2.useState注意事项：

+ 只能出现在函数组件中
+ 不能嵌套在if / for /其他函数中(react按照hooks的调用顺序识别每一个hook)
+ 在react内部通过顺序对应的，所以useState不能加判断循环，位置会调换

#### 7.useEffect

 什么是副作用？

一个函数处除了主作用，其他的作用就是副作用，对于React组件来说，主作用是根据数据渲染UI，除此之外都是副作用

常见的副作用：

+ 数据请求Ajax发送
+ 手动修改DOM
+ localStorage操作

useEffect函数的作用就是为react函数组件提供副作用的处理

使用步骤：

1.导入useEffect函数

2.调用useEffect函数，并传入回调函数

3.在回调函数中编写副作用处理(dom操作)

#### 8.依赖项控制执行的时机

8.1 不添加依赖项

>  组件首次渲染执行一次，以及不管是那个状态更改引起组件更新时都会重新执行
>
> 1.组件初始渲染
>
> 2.组件更新 (不管是哪个状态引起的更新)

useEffect(( ) => {

​	console.log('副作用执行了')

})

8.2 添加空数组

> 组件只在首次渲染时执行一次

useEffect( ( ) => {

console.log('副作用执行了');

} )

8.3 添加特定的依赖项

> 副作用函数在首次渲染时执行，在依赖项发生变化时重新执行



注意事项：只要useEffect回调函数中用到的函数状态就应该出现在依赖项数组中声明，否则会出现bug

某种意义上 hook的出现  就是想不用生命周期概念也可以写业务代码



