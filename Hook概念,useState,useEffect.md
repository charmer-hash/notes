### Hook概念

#### 1.什么是Hook？

> Hook的本质： 一套能够使函数组件更强大，更灵活的钩子

经过多年的实战，函数组件是一个更加匹配React的设计理念UI = f（data）

也更有利于逻辑拆分与重用的组件表达形式，而先前的函数组件是不可以有自己的状态的，为了能让函数组件可以拥有自己的状态，所以从v16.8开始，hooks应运而生。

注意点：

+ 1.有了hooks之后，为了兼容老版本，class类组件并没有被移除，二者都可以使用
+ 2.有了hooks之后，不能再把函数变成无状态组件了，因为hooks为函数提供了状态
+ hooks只能在函数组件中使用

#### 2.hooks的出现解决了两个问题

+ 1.组件的状态逻辑复用
+ 2.class组件自身的问题

组件的逻辑复用：

​	在hooks出现之前，react先后尝试了mixins混入，HOC高阶组件，render-props等模式

但是都有各自的问题，比如mixin的数据来源不清晰，高阶组件的嵌套问题

class组件自身的问题：

class组件就像一个厚重的‘战舰’一样，大而全，提供了很多东西，有不可忽视的学习成本，比如各种生命周期，this的指向问题等，而我们更多时候需要的是一个轻快灵活的‘快艇’

#### 3.Hooks优势：

+ 1.告别了难以理解的class
+ 2.解决业务逻辑难以拆分的问题
+ 3.使状态逻辑复用变得简单可行
+ 4.函数组件在设计思想上，更加契合React的理念

#### 4.useState

使用步骤:

1.从react中导入useState这个方法

2.在函数组件的内部执行这个方法，并且传入一个初始值

3.通过解构赋值，得到数据状态和一个修改数据状态的方法

4.渲染数据状态，在某个时机下通过执行方法修改状态

const [count,setCount] = useState(0)

5.useState传过来的参数，作为count的初始值

6.[count,setCount] 这里的写法是一个解构赋值，useState返回值是一个数组

7.setCount函数作用,用来修改count 依旧保持不能拿直接修改原值，还是生成一个新值替换原值，setCount(基于原值计算得到的新值）

8. count和setCount是一对，是绑在一起的，setCount只能用来修改对应的count值



#### 5.组件的更新过程

函数组件使用useState hook后的执行过程

+ 组件第一次渲染
  +  从头开始执行该组件中的代码逻辑
  + 调用useState(0)，将传入的参数作为状态初始值，即：0
  + 渲染组件，此时，获取到的状态count值为：0
+ 组件第二次渲染
  + 点击按钮调用setCount(count + 1)修改状态，因为状态发生改变，所以该组件会重新渲染
  + 组件重新渲染时，会再次执行该组件中的代码逻辑
  + 再次调用useState(0),此时React内部回拿到最新的状态值而非初始值，比如案例中最新状态值为1
  + 再次渲染组件，获取的状态count值为1

#### 6.组件的使用规则

1.useState函数可以执行多次，每次执行相互独立，每调用一次为函数组件提供一个状态

2.useState注意事项：

+ 只能出现在函数组件中
+ 不能嵌套在if / for /其他函数中(react按照hooks的调用顺序识别每一个hook)
+ 在react内部通过顺序对应的，所以useState不能加判断循环，位置会调换

#### 7.useEffect

 什么是副作用？

一个函数处除了主作用，其他的作用就是副作用，对于React组件来说，主作用是根据数据渲染UI，除此之外都是副作用

常见的副作用：

+ 数据请求Ajax发送
+ 手动修改DOM
+ localStorage操作

useEffect函数的作用就是为react函数组件提供副作用的处理

使用步骤：

1.导入useEffect函数

2.调用useEffect函数，并传入回调函数

3.在回调函数中编写副作用处理(dom操作)

#### 8.依赖项控制执行的时机

8.1 不添加依赖项

>  组件首次渲染执行一次，以及不管是那个状态更改引起组件更新时都会重新执行
>
> 1.组件初始渲染
>
> 2.组件更新 (不管是哪个状态引起的更新)

useEffect(( ) => {

​	console.log('副作用执行了')

})

8.2 添加空数组

> 组件只在首次渲染时执行一次

useEffect( ( ) => {

console.log('副作用执行了');

} )

8.3 添加特定的依赖项

> 副作用函数在首次渲染时执行，在依赖项发生变化时重新执行



注意事项：只要useEffect回调函数中用到的函数状态就应该出现在依赖项数组中声明，否则会出现bug

某种意义上 hook的出现  就是想不用生命周期概念也可以写业务代码



#### 9.useState --- 回调函数的参数

使用场景： 只会在组件初始化渲染中起作用，后续渲染时会被忽略，如果初始state需要通过计算才能获得，则可以传入一个函数，在函数中计算并返回初始的state,此函数只在初始渲染时被调用

**语法**

```javascript
const [name,setName] = useState( () => { //编写计算逻辑  return '计算之后的初始值'})
```

语法规则：

+ 回调函数return出去的值将作为name的初始值

+ 回调函数中的逻辑只会在组件初始化的时候执行一次

  

语法选择

+ 1.如果就是初始化一个普通的数据，直接使用useState(普通数据)即可
+ 2.如果要初始化的数据无法得到需要通过计算才能获取到，使用useState( () => {} )

#### 10.useEffect - 清理副作用

使用场景：在组件被销毁时，如果有些副作用操作需要被清理，就可以使用此语法，比如常见的定时器

语法及规则

```
useEffect(() => {
	console.log('副作用函数执行了');
	return () => {
	console.log('清理副作用的函数执行了');
	}
})
```

#### 11.定时器小案列

添加副作用函数前：组件虽然已经不显示了，但是定时器依旧运行

```javascript
function Foo() {
  useEffect(() => {
    let timer = setInterval(() => {
        console.log('副作用函数执行了');
      },1000);
      return () => {
        clearInterval(timer);
      }
  },[])
  return <div>Foo</div>
}

function App() {
  const [flag, setFlag] = useState(true);
  return (
    <div >
      { flag ? <Foo></Foo> : null}
      <button onClick={ () => setFlag(!flag)}>switch</button>
    </div>
  )
}
```

#### 12.发送网络请求

useEffect

1. 不加依赖项  -- 初始化 + 重新渲染

2. 加 [ ] - 初始化执行一次

3. 加特定的依赖项  [count,name]  -- 首次执行 + 任意一个变化执行

#### 13.useRef

使用场景:

在函数组件中获取真实的DOM对象或者是组件对象

使用步骤：

+ 1.导入useRef函数
+ 2.执行useRef函数并传入null，返回值是一个对象，内部有一个current属性存放拿到的dom对象(组件实例)
+ 3.通过ref 绑定要获取的元素或者组件

> useEffect回调，是在dom渲染之后执行
